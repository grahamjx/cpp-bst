### Design Write-Up
Following the guidelines of the assignment, I created a class "table" thats acts as a manager of my data structure, a binary search tree. For my implementation, I also created a struct which is used for the data containing each rental property entered by the user.
The table class lies at the center of my implementation of the Table ADT and its public process are limited to inserting, retrieving, removing and displaying information. To meet the requirements of the assignment, each major operation carried out on the BST is done using recursion. To accomplish this task, I created five public member functions in addition to the constructor and destructor, to allow the client side of the program to talk with the table class. Each of the functions is associated with a specific recursion function that is defined in the private section of the class. In this way, the public functions act as 'wrapper' functions which handle the basic process of checking to see if the tree is empty before calling on the recursion function to carry out the selected operation. Structuring the class in this way allows for greater security and separation of the client side of the program from the ADT. Since the recursive functions needed to take in a node as an argument, it makes sense to place them in private section since the client side of the program should not have access to the underlying data structure.

Since my public member functions of my table class act as wrapper functions, I kept them simple. All the functions with the exception of insert, handle the checking of root to see if the tree is empty. That way the recursion portion of the operation would not be called in the event of an empty tree. This allowed for one less function call as well as the ability to keep the public and its corresponding private function clean and easy to manage. For my implementation, I also tried to give most of the 'power'  to the associated recursive function instead of returning values or nodes out for use in the calling function before returning back to main. From a design consideration standpoint this provided more flexibility to my ADT since each public function was merely a shell that I could pass information into before carrying out the recursion. This flexibility could be useful if a person wanted to change which data field was used when adding information to the BST. With a few quick changes, the tree could instead be assembled in-order based on location instead. This type of flexibility was important to me when thinking about ways a Table ADT like mine could be used in other real world scenarios.

Likely the most complicated recursion function is my remove_tree function. Since removal from a BST requires multiple checks before removal, this function can be somewhat confusing. Removal of a leaf or a node with only one child were relatively simple. Removal of a node with two children does require some additional work to find the in-order successor. I opted to nest the loop portion of this type of the removal in the same recursive function as the other cases. This does add further complexity to the function, however, by keeping them all together I feel like the operation can be done more seamlessly. I experimented with a few other methods before implementing it in this way. One of them included passing the node as reference back to the calling function before running the loop to find the in-order successor. Although I may have eventually got this particular implementation to work, it seemed counter intuitive to the way I had created my other public functions. Through keeping each public function simple, the private recursive counterpart felt like a more appropriate place to carry out all the operations relating to the item removal. Implementing remove in this way also lead to less memory overhead by reducing the number of temporary variables needed in both the recursive function and in the calling function. I feel like my solution is a good combination of keeping process succinct but still remaining flexible if need be.

This assignment is also the first one this term where I decided to switch from using a class to a struct in order to manage my data members. When I initially started programming this assignment I continued to use a class. However, the more my recursive functions took shape, the glaring inefficiency of my implementation became clear. For my recursive functions I wanted to keep the overhead to a minimum. I wanted them to only take in the absolute necessities as arguments in order to complete the task. In addition, I wanted to make sure that I kept creation of local variables to a minimum as well since the memory efficiency could become significantly bloated if a large number of local variables were created with each iteration of the function. When using my class implementation in the past, I used functions that would 'get' and 'set' the data in each class object. Because of this, when ever I wanted to extract data from an object I would have to first put the data for each variable into a local variable before displaying it or setting it into another object. Not only did this process add significant code to my overall assignment, when dealing with recursive functions it became a huge inefficiency. Take for example my search_nickname recursive function in this assignment. The user enters a nickname that they want to search for in main and any matches would be saved into the an array. The search word and the array are passed into the retrieve_nickname public member function which in-turn calls the recursive function search_name. When using my class implementation, I would have to create five local variables that would have to temporarily save the data coming out of the object so I could set the data in the results array. This process isn't so bad when using a loop implementation because the allocation of the memory is only done once and the same memory can be used over and over again. In the recursive solution, each iteration of the function would create a new set of local variables. Depending on the height of the tree and the length of the search, this process could generate a large number of local variables that may or may not contain any information. Although eventually when the recursion was complete the memory would be freed off the stack, it still made the recursive process of finding matching data to use significantly more memory. This use of memory would also be more inefficient if some of the local variables needed to be character arrays with a standard size to hold the value temporarily. Switching to a struct cleared a significant number of these issue up. Not only was I able to keep my recursive function arguments and local variables to a minimum, I was able to create just a single additional private function in order do a deep copy of data from one object to another. This was a huge design consideration for me and I feel like it was a great choice in making my program not only easier to read but more efficient in the long run.

As far using a binary search tree as the data structure in my implementation, I found it was a pretty solid choice. The ability to insert based on nickname and retrieve the data in-order is handled in a great way. In addition, searching by a different variable other than the one used for insert (price) was simple, clean and pretty efficient. I found that the overall flexibility of the data structure opens up a lot of possibilities for organizing and retrieving information in a lot of different ways. In the past Table ADT assignment, we were required to insert our data into two separate data structures in order to retrieve and display data in the order we wanted. Using the BST, the memory overhead was considerably lower since I only had to manage one data structure. Runtime efficiency was also an improvement when comparing the two implementations. Inserting data into the past implementation took longer since it had to be added to two places. Combining that with the need to insert in sorted order in the DLL, this lead to a longer overall process. Since items were added to the tree in simple terms, implementing the function recursively was a great and effective way of adding items in a timely manner. Since the BST only needed to check if the new item nickname value was less than or greater/equal than, the process could be streamlined and done in a straightforward manner without the need for considerable value checks and pointer updates like when dealing with a DLL. Of course, the BST isn't without its faults. If the item added first has a small value then the tree will likely become disproportionate, with significantly more items being added to the right of the root. One possible alternative would be implementing a 2-3 tree instead of a standard BST. The benefit of a 2-3 is that they are balanced and a balanced structure is pretty easy to maintained. If the structure is balanced than searching the tree in any situation falls within the logarithmic efficiency of the binary search. That way, the tree wouldn't have a string of continus right children which has the poor efficiency associated with a LLL. A balanced tree would allow greater efficiency on all inserts  and searches of the tree and remove the profound effect on the efficiency that the first data item has in my implementation of the BST.

If I had more time to work on this project, I would like to further experiment with using different data variables when carrying out the insertion process. Some possible options would be by location or even expanding it to allow for GPS location if I wanted to look into more real world implementations. I also would have liked to try using different types of trees especially ones that maintained balance so that all the ADT process could be more efficient regardless of what item was inserted at the beginning.
